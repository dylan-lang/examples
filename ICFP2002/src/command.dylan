module: command

define constant $north = #"north";
define constant $south = #"south";
define constant $east  = #"east";
define constant $west  = #"west";
define constant <direction> = one-of($north, $south, $east, $west);

define abstract class <command> (<object>)
  constant slot bid :: <integer>,
    required-init-keyword: bid:;
  constant slot robot-id :: <integer>, required-init-keyword: id:;
end class <command>;

define class <pick> (<command>)
  constant slot package-ids :: <sequence>, // of <integer>
    required-init-keyword: package-ids:;
end class <pick>;

define class <drop> (<command>)
  constant slot package-ids :: <sequence>, // of <integer>
    required-init-keyword: package-ids:;
end class <drop>;

define class <move> (<command>)
  constant slot direction :: <direction>,
    required-init-keyword: direction:;
end class <move>;

// <transport> is generated by the server to inform the client
// if a robots new location.
define class <transport> (<command>)
  constant slot transport-location :: <point>, required-init-keyword: location:;
end class <transport>;

// TODO: add an initializer to make sure that every element of
// package-ids is an <integer>

define method print-object (c :: <pick>, s :: <stream>) => ()
  format(s, "{<pick> robot-id: %d, bid: %d, package-ids: %=}",
         c.robot-id, c.bid, c.package-ids);
end method print-object;

define method print-object (c :: <move>, s :: <stream>) => ()
  format(s, "{<move> robot-id: %d, bid: %d, move: %=}",
         c.robot-id, c.bid, c.direction);
end method print-object;

define method print-object (c :: <drop>, s :: <stream>) => ()
  format(s, "{<drop> robot-id: %d, bid: %d, package-ids: %=}",
         c.robot-id, c.bid, c.package-ids);
end method print-object;

define method print-object (c :: <transport>, s :: <stream>) => ()
  format(s, "{<transport> robot-id: %d, bid: %d, transport-location: %=}",
         c.robot-id, c.bid, c.transport-location);
end method print-object;

define generic process-command(state :: <state>, command :: <command>) => (state :: <state>);

// Ignore commands I don't handle for now.
define method process-command(state :: <state>, command :: <command>) => (state :: <state>)
  state   
end method process-command;

define method process-command(state :: <state>, command :: <move>) => (state :: <state>)
  let bot = find-robot(state, command.robot-id);
  let new-money = bot.money & bot.money - abs(command.bid);
  let old-location = bot.location;
  let new-location =
    select (command.direction)
      $north => point(x: old-location.x,     y: old-location.y + 1);
      $east  => point(x: old-location.x + 1, y: old-location.y);
      $south => point(x: old-location.x,     y: old-location.y - 1);
      $west  => point(x: old-location.x - 1, y: old-location.y);
    otherwise => error("process-command: Can't happen!")
  end select;
  // kill robots here
  let terrain = terrain-at-point(state.board, new-location);
  if(robot-at(state, new-location))
    // push;
  end if;
  if(instance?(terrain, <water>))
    state := remove-robot-by-id(state, command.robot-id);
    let ps = choose(method(p) p.carrier & p.carrier.id = bot.id end,
                    state.packages);
    for(p in ps)
      state := remove-package-by-id(state, p.id);
    end for;
    state
  else
    let new-bot = copy-robot(bot, new-location: new-location, new-money: new-money);
    
    // For this bot, work through all the packages it carries and
    // update it's location.
    let ps = choose(method(p) p.carrier & p.carrier.id = bot.id end,
                    state.packages);
    for(p in ps)
      state := add-package(state, copy-package(find-package(state, p.id), 
                                               new-location: new-location));
    end for;
    let x = add-robot(state, copy-robot(bot, new-location: new-location,
                                        new-money: new-money));
    x
  end if;
end method process-command;

define method process-command(state :: <state>, command :: <pick>) => (state :: <state>)
  let bot = find-robot(state, command.robot-id);
  let new-money = bot.money & bot.money - abs(command.bid);
  let loc = bot.location;
  for(pid in command.package-ids)
    let package* = copy-package(find-package(state, pid, create: #t), 
					     new-location: loc, 
					     new-carrier: bot);
    state := add-package(state, package*);
    let inv = remove(bot.inventory, pid, test: method(x, y) x.id == y end);
    let inv = add(bot.inventory, package*);
    state := add-robot(state, copy-robot(bot, 
                                         new-inventory: inv,
                                         new-money: new-money));
  end for;
  state;
end method process-command;

define method process-command(state :: <state>, command :: <drop>)
 => (state :: <state>)
  let loc = find-robot(state, command.robot-id).location;
  for(pid in command.package-ids)
    let p = find-package(state, pid, create: #t);
    if (loc = p.dest) // We are at the destination, so kill the package
      let packages* = remove(state.packages, p,
                             test: method (p*, p) p*.id = p.id end method);
      state := make(<state>,
                    board: state.board,
                    bases: state.bases,
                    robots: state.robots,
                    packages: packages*);
    else // otherwise just put the package on the floor.
      state := add-package(state, copy-package(p,
                                               new-location: loc,
                                               new-carrier: #f));
    end if;
    let bot = find-robot(state, command.robot-id);
    let new-money = bot.money & bot.money - abs(command.bid);
//    let new-score = if(p.weight) bot.score else bot.score + p.weight end;
    let new-inventory = remove(bot.inventory, p,
                               test: method (p*, p) p*.id = p.id end method);
    let bot* = copy-robot(bot, new-inventory: new-inventory, new-money: new-money);
    state := add-robot(state, bot*);
  end for;
  state;
end method process-command;

define method process-command(state :: <state>, command :: <transport>)
 => (state :: <state>)
  if (robot-exists?(state, command.robot-id))
    //  
    // This bot is on our list, so we need to move it, and all of the
    // packages it's carrying.
    //
    let bot :: <robot> = find-robot(state, command.robot-id);
    let ps = choose(method(p) p.carrier.id = bot.id end, state.packages);
    for(p in ps)
      let moved-package :: <package> =
        copy-package(find-package(state, p.id),
                     new-location: command.transport-location);
      state := add-package(state, moved-package);
    end for;
    add-robot(state, copy-robot(bot, new-location: command.transport-location));
  else
    // The robot isn't on our list, so it's a new robot that's just
    // joined the game. We need to add it to the list, and update the
    // world state. There's no need to frob with packages as above, because
    // robots enter the world with no packages.
    //
    let new-bot :: <robot> = make(<robot>,
                                  id: command.robot-id,
                                  location: command.transport-location);
    state := add-robot(state, new-bot);
    //
    state;
  end if;
end method process-command;
